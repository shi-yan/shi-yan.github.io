<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <!-- Primary Meta Tags -->
    <title>Shi&#x27;s blog: How to Render a Single Gaussian Splat?</title>
    <meta name="title" content="How to Render a Single Gaussian Splat?" />
    <meta name="description" content="In this tutorial we will look at how to properly render a single gaussian splat." />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://shi-yan.github.io/how_to_render_a_single_gaussian_splat" />
    <meta property="og:title" content="How to Render a Single Gaussian Splat?" />
    <meta property="og:description" content="In this tutorial we will look at how to properly render a single gaussian splat." />
    <meta property="og:image" content="https://shi-yan.github.io/how_to_render_a_single_gaussian_splat/thumb_result.png" />

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content="https://shi-yan.github.io/how_to_render_a_single_gaussian_splat" />
    <meta property="twitter:title" content="How to Render a Single Gaussian Splat?" />
    <meta property="twitter:description" content="In this tutorial we will look at how to properly render a single gaussian splat." />
    <meta property="twitter:image" content="https://shi-yan.github.io/how_to_render_a_single_gaussian_splat/thumb_result.png" />

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>


    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/base16/default-dark.min.css"
        integrity="sha512-EF2rc4QyBiRAGUMVm+EjFPBbdVGaN/pwZhtuKyrC/dM+hcwTxI5BsEDUkrMRI77z4VlDAt/qVopePXB5+ZZ8Gw=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />

    <link rel="alternate" type="application/rss+xml" title="Shi&#x27;s blog" href="https://shi-yan.github.io/rss.xml" />

    <link rel="stylesheet" href="/style.css" />

    <script src="
        https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js
        "></script>
    <link href="
        https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css
        " rel="stylesheet" />
</head>

<body>
    <div id="page">
        <div id="header"><a class="icon" href="/">Shi&#x27;s blog</a> <a class="icon" href="https://github.com/shi-yan"><svg
                    xmlns="http://www.w3.org/2000/svg" height="32" width="32" fill="#dadadb"
                    viewBox="0 0 480 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.-->
                    <path
                        d="M186.1 328.7c0 20.9-10.9 55.1-36.7 55.1s-36.7-34.2-36.7-55.1 10.9-55.1 36.7-55.1 36.7 34.2 36.7 55.1zM480 278.2c0 31.9-3.2 65.7-17.5 95-37.9 76.6-142.1 74.8-216.7 74.8-75.8 0-186.2 2.7-225.6-74.8-14.6-29-20.2-63.1-20.2-95 0-41.9 13.9-81.5 41.5-113.6-5.2-15.8-7.7-32.4-7.7-48.8 0-21.5 4.9-32.3 14.6-51.8 45.3 0 74.3 9 108.8 36 29-6.9 58.8-10 88.7-10 27 0 54.2 2.9 80.4 9.2 34-26.7 63-35.2 107.8-35.2 9.8 19.5 14.6 30.3 14.6 51.8 0 16.4-2.6 32.7-7.7 48.2 27.5 32.4 39 72.3 39 114.2zm-64.3 50.5c0-43.9-26.7-82.6-73.5-82.6-18.9 0-37 3.4-56 6-14.9 2.3-29.8 3.2-45.1 3.2-15.2 0-30.1-.9-45.1-3.2-18.7-2.6-37-6-56-6-46.8 0-73.5 38.7-73.5 82.6 0 87.8 80.4 101.3 150.4 101.3h48.2c70.3 0 150.6-13.4 150.6-101.3zm-82.6-55.1c-25.8 0-36.7 34.2-36.7 55.1s10.9 55.1 36.7 55.1 36.7-34.2 36.7-55.1-10.9-55.1-36.7-55.1z" />
                </svg></a>
            <a class="icon" href="https://shi-yan.github.io/rss.xml" target="_blank"><svg xmlns="http://www.w3.org/2000/svg"
                    height="32" width="32" fill="#dadadb"
                    viewBox="0 0 448 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.-->
                    <path
                        d="M0 64C0 46.3 14.3 32 32 32c229.8 0 416 186.2 416 416c0 17.7-14.3 32-32 32s-32-14.3-32-32C384 253.6 226.4 96 32 96C14.3 96 0 81.7 0 64zM0 416a64 64 0 1 1 128 0A64 64 0 1 1 0 416zM32 160c159.1 0 288 128.9 288 288c0 17.7-14.3 32-32 32s-32-14.3-32-32c0-123.7-100.3-224-224-224c-17.7 0-32-14.3-32-32s14.3-32 32-32z" />
                </svg>
            </a>
        </div>
        <div id="left"></div>
        <div id="content">
            <div id="title">How to Render a Single Gaussian Splat?</div>
            <div id="meta"><svg xmlns="http://www.w3.org/2000/svg" height="12" width="11" fill="#dadadb"
                    viewBox="0 0 448 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.-->
                    <path
                        d="M152 24c0-13.3-10.7-24-24-24s-24 10.7-24 24V64H64C28.7 64 0 92.7 0 128v16 48V448c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V192 144 128c0-35.3-28.7-64-64-64H344V24c0-13.3-10.7-24-24-24s-24 10.7-24 24V64H152V24zM48 192h80v56H48V192zm0 104h80v64H48V296zm128 0h96v64H176V296zm144 0h80v64H320V296zm80-48H320V192h80v56zm0 160v40c0 8.8-7.2 16-16 16H320V408h80zm-128 0v56H176V408h96zm-144 0v56H64c-8.8 0-16-7.2-16-16V408h80zM272 248H176V192h96v56z" />
                </svg> 2024-02-24 <svg xmlns="http://www.w3.org/2000/svg" style="margin-left:16px;" height="12" width="11"
                    fill="#dadadb"
                    viewBox="0 0 512 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.-->
                    <path
                        d="M345 39.1L472.8 168.4c52.4 53 52.4 138.2 0 191.2L360.8 472.9c-9.3 9.4-24.5 9.5-33.9 .2s-9.5-24.5-.2-33.9L438.6 325.9c33.9-34.3 33.9-89.4 0-123.7L310.9 72.9c-9.3-9.4-9.2-24.6 .2-33.9s24.6-9.2 33.9 .2zM0 229.5V80C0 53.5 21.5 32 48 32H197.5c17 0 33.3 6.7 45.3 18.7l168 168c25 25 25 65.5 0 90.5L277.3 442.7c-25 25-65.5 25-90.5 0l-168-168C6.7 262.7 0 246.5 0 229.5zM144 144a32 32 0 1 0 -64 0 32 32 0 1 0 64 0z" />
                </svg>
                <a class="tag" href="/tags/gaussian-splat">#gaussian splat</a>,
                <a class="tag" href="/tags/computer-graphics">#computer graphics</a>,
                <svg xmlns="http://www.w3.org/2000/svg" style="margin-left:16px;" height="12" width="11" fill="#dadadb"
                    viewBox="0 0 384 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.-->
                    <path
                        d="M320 464c8.8 0 16-7.2 16-16V160H256c-17.7 0-32-14.3-32-32V48H64c-8.8 0-16 7.2-16 16V448c0 8.8 7.2 16 16 16H320zM0 64C0 28.7 28.7 0 64 0H229.5c17 0 33.3 6.7 45.3 18.7l90.5 90.5c12 12 18.7 28.3 18.7 45.3V448c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V64z" />
                </svg>
                2270 Words
                <svg xmlns="http://www.w3.org/2000/svg" style="margin-left:16px;" height="12" width="11" fill="#dadadb"
                    viewBox="0 0 512 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.-->
                    <path
                        d="M464 256A208 208 0 1 1 48 256a208 208 0 1 1 416 0zM0 256a256 256 0 1 0 512 0A256 256 0 1 0 0 256zM232 120V256c0 8 4 15.5 10.7 20l96 64c11 7.4 25.9 4.4 33.3-6.7s4.4-25.9-6.7-33.3L280 243.2V120c0-13.3-10.7-24-24-24s-24 10.7-24 24z" />
                </svg>
                9 Mins
            </div>
            <article id="post"><p><a class="link" href="https://aras-p.info/blog/2023/12/08/Gaussian-explosion/" target="_blank">Gaussian Splatting</a> has garnered significant attention since last year, particularly following this <a class="link" href="https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/" target="_blank">paper</a>. This technique has piqued my interest due to its potential to become a standard approach for implementing 3D photography.</p><iframe class="video" src="https://www.youtube.com/embed/mD0oBE9LJTQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><p>Traditional computer graphics predominantly represent 3D scenes using triangles, and GPU hardware is optimized for rendering large quantities of triangles efficiently. The quest for reconstructing a realistic 3D scene from a set of photos taken from different angles has been a vibrant research area. However, achieving photorealism remains a challenge. Triangles fall short when it comes to representing fuzzy, transparent, or non-distinctive objects like clouds or hair.</p><p>In recent years, there have been advancements in implicit 3D representations such as neural radiance fields. These methods can generate photorealistic results and handle non-distinctive objects well, albeit at the cost of intense computation and slow rendering speeds. Subsequently, researchers have been exploring new solutions that can bridge the gap between these approaches. Gaussian splatting emerges as a potential solution. However, this is a rapidly evolving field, with new methods coming out attempting to address some of the limitations of Gaussian splatting. Nevertheless, understanding Gaussian splatting deeply is worthwhile, as it may form the foundation for many future methods.</p><p>In this post, we'll explore how to render a single Gaussian splat and make sense of its mathematics. This post alone won't be sufficient to render an entire Gaussian splatting scene, but it will dive into the core aspects of the technique. Similar to my other posts, rather than focusing on mathematical rigor, I'd like to emphasize intuition, as I believe it is crucial for understanding complex concepts. For those interested in formal descriptions of the method, I'll recommend additional resources. I've also received invaluable assistance from the <a class="link" href="https://github.com/mkkellogg/GaussianSplats3D" target="_blank">GaussianSplats3D
</a> reference implementation in Three.js. I highly recommend checking out this project.</p><p>I plan to provide a full implementation of Gaussian splatting as an example for the <a class="link" href="https://github.com/shi-yan/WebGPUUnleashed" target="_blank">WebGPU book</a> I'm currently working on.</p><p><div class="img-container"><img class="img" onclick="openImage(this)" src="surface_splatting.png" alt="Surface Splatting" sources='["https://www.cs.umd.edu/~zwicker/publications/SurfaceSplatting-SIG01.pdf"]' /><div class="img-title">Surface Splatting<a class="img-source" target="_blank" href="https://www.cs.umd.edu/~zwicker/publications/SurfaceSplatting-SIG01.pdf">[SOURCE]</a></div></div></p><p>What is Gaussian Splatting? As previously mentioned, while triangles are the most commonly used graphics element, there has been a pursuit of using other primitives instead of triangles as the basis for rendering. Points, for example, have been another common choice. Points don't require explicit connectivity, making them handy when representing a 3D scene where connectivity is difficult to sort out, such as those captured using a 3D scanner or LiDAR. However, points don't have size. When viewed closely, points might not be dense enough to cover a surface. One idea for alleviating this problem is to render small disks, called <a class="link" href="https://www.cs.umd.edu/~zwicker/publications/SurfaceSplatting-SIG01.pdf" target="_blank">surface splats</a>, instead of points. Because a disk can have a size, tweaking their size can help cover the holes. The disks usually don't have a solid color but have a fading color on the edge defined by a Gaussian. This is useful to blend nearby disks to create a smooth transition.</p><p><div class="img-container"><img class="img" onclick="openImage(this)" src="thumb_volume_rabbit.webp" original_src="volume_rabbit.webp" alt="Volume Rendered Fuzzy Object" sources='["https://help.maxon.net/c4d/s26/en-us/Content/_REDSHIFT_/html/Volume+Rendering.html"]' /><div class="img-title">Volume Rendered Fuzzy Object<a class="img-source" target="_blank" href="https://help.maxon.net/c4d/s26/en-us/Content/_REDSHIFT_/html/Volume+Rendering.html">[SOURCE]</a></div></div></p><p>Another common choice is called volume rendering. A volume is a 3D grid of voxels, which can be viewed as 3D pixels that absorb light. We shoot out rays from the camera and test the intersection between the rays and the voxels, blending their color values along each ray. Voxel rendering excels in representing fuzzy surfaces, but the traditional way of storing a volume is very costly.</p><p>Gaussian splatting can be viewed as a hybrid of the two. Each rendering element is a 3D Gaussian function, or a blob. It has a position and a size, similar to a surface splat. But unlike a surface splat, a Gaussian splat also has a volume, not just in 2D. Moreover, a Gaussian splat has a shape. The basic shape is a sphere, but we can stretch and rotate it into an arbitrary ellipsoid. The color defined in a Gaussian splat fades too according to its defining Gaussian function, similar to a surface splat. Gaussian splatting combines the benefits of both aforementioned approaches. It doesn't require connectivity, it's sparse, and is capable of representing fuzzy surfaces.</p><p>Although Gaussian splatting gained popularity last year through this <a class="link" href="https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/" target="_blank">paper</a>, the concept isn't new, as the rendering part was first mentioned in this <a class="link" href="https://www.cs.umd.edu/~zwicker/publications/EWAVolumeSplatting-VIS01.pdf" target="_blank">paper</a>. To summarize the process, given a scene with many Gaussian splats, we first perform a series of rotations and scalings on them, similar to what we do to vertices in the normal rendering process. Then, these splats are projected onto the screen as 2D Gaussians. Finally, they are sorted based on depth for applying front-to-back blending.</p><iframe class="video" src="https://www.youtube.com/embed/Tnij_xHEnXc?t=75" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><p>If you're finding it challenging to visualize this concept, I recommend watching the YouTube video linked above to gain a clearer understanding.</p><p>To understand how to render a Gaussian splat, we need to be familiar with the geometric interpretation of a 3D Gaussian function. For that, I recommend this <a class="link" href="https://users.cs.utah.edu/~tch/CS4640F2019/resources/A%20geometric%20interpretation%20of%20the%20covariance%20matrix.pdf" target="_blank">document</a>. I will skip the details and summarize what's useful for our implementation.</p><p>A 3D Gaussian is defined by two parameters: a centroid and a 3x3 covariance matrix. Intuitively, the centroid is the position of a Gaussian, and the covariance matrix defines the shape of the Gaussian (an ellipsoid).</p><p class="katex-display-counter"><code class="language-math math-block">  \mathcal{N}(\mu, \sigma^2)</code></p><p>If we consider 1D Gaussians, they are defined by a mean <code class="language-math math-inline">\mu</code> and a variance <code class="language-math math-inline">\sigma^2</code>. In this context, the mean <code class="language-math math-inline">\mu</code> dictates the center of the Gaussian on the x-axis, while <code class="language-math math-inline">\sigma^2</code> determines its spread or shape.</p><p><div class="img-container"><img class="img" onclick="openImage(this)" src="thumb_normal_distribution.png" original_src="normal_distribution.png" alt="1D Gaussians of Different Means and Variances" sources='["https://en.wikipedia.org/wiki/Normal_distribution"]' /><div class="img-title">1D Gaussians of Different Means and Variances<a class="img-source" target="_blank" href="https://en.wikipedia.org/wiki/Normal_distribution">[SOURCE]</a></div></div></p><p>The same principle extends to 2D and 3D Gaussians, where they are defined by a mean <code class="language-math math-inline">\mu</code> (or centroid) and a covariance matrix <code class="language-math math-inline">\Sigma</code>. In 2D, the covariance <code class="language-math math-inline">\Sigma</code> is a 2x2 matrix, and in 3D, it is a 3x3 matrix. The covariance matrix holds geometric significance, defining the ellipsoidal shape of the Gaussian.</p><p class="katex-display-counter"><code class="language-math math-block">  \mathcal{N}(\mu, \Sigma)</code></p><p>Below is an illustration showing various 2D Gaussian shapes and their corresponding covariances.</p><p><div class="img-container"><img class="img" onclick="openImage(this)" src="thumb_2d_splats.png" original_src="2d_splats.png" alt="2D Gaussian Shapes and Their Covariances" sources='["https://users.cs.utah.edu/~tch/CS4640F2019/resources/A%20geometric%20interpretation%20of%20the%20covariance%20matrix.pdf"]' /><div class="img-title">2D Gaussian Shapes and Their Covariances<a class="img-source" target="_blank" href="https://users.cs.utah.edu/~tch/CS4640F2019/resources/A%20geometric%20interpretation%20of%20the%20covariance%20matrix.pdf">[SOURCE]</a></div></div></p><p>We can shift the centroid to adjust a Gaussian's position, and we can also rotate and scale the covariance matrix to modify its shape. This process is akin to applying a model-view matrix to vertices during rendering, although the mathematical operations involved are not identical.</p><p>The fundamental insight from the geometric interpretation outlined in the <a class="link" href="https://users.cs.utah.edu/~tch/CS4640F2019/resources/A%20geometric%20interpretation%20of%20the%20covariance%20matrix.pdf" target="_blank">document</a> is that the covariance matrix <code class="language-math math-inline">\Sigma</code> specifies a rotation and scaling transformation that morphs a standard Gaussian with the identity matrix <code class="language-math math-inline">\mathbf I</code> as its covariance into an ellipsoidal shape. Let this transformation be represented by a 3x3 matrix <code class="language-math math-inline">\textit{T}</code>; it can be factored into a product of a 3x3 rotation matrix <code class="language-math math-inline">\textit{R}</code> and a scaling matrix <code class="language-math math-inline">\textit{S}</code>. Thus:</p><p class="katex-display-counter"><code class="language-math math-block">  \begin{aligned}
  \Sigma &= \textit{T} \textit{I} \textit{T}^\top \\
  \Sigma &= \textit{R} \textit{S} (\textit{R} \textit{S})^\top \\
  \Sigma &= \textit{R} \textit{S} \textit{S}^\top \textit{R}^\top \\
  \end{aligned}</code></p><p>Additionally, if we wish to apply an additional transformation <code class="language-math math-inline">\textit{V}</code> to the covariance matrix, we can do so using the formula <code class="language-math math-inline">\Sigma^\prime = \textit{V} \Sigma \textit{V}^\top</code>. This is crucial for tasks such as <a class="link" href="https://stats.stackexchange.com/questions/484094/projecting-a-covariance-matrix-to-a-lower-dimensional-space" target="_blank">implementing projection</a> of the 3D covariance into 2D space.</p><p>Before examining into rendering Gaussian splats, it's crucial to establish a ground truth. Debugging graphics programs can be challenging, so visualizing the rendering result against this ground truth is essential to ensure the implementation's correctness. There are two primary methods to create the ground truth:</p><ol><li><p>Generate a point cloud from a Gaussian distribution, where the Gaussian value serves as the sample density.</p></li><li><p>Deform a sphere into an ellipsoid based on the same transformation defined by the Gaussian's covariance matrix.</p></li></ol><p>Once the Gaussian splat has been rendered, we anticipate seeing it overlap with the ground truth, providing a visual confirmation of the accuracy of the implementation.</p><p>In this post, I'll use the first method. Python offers excellent support for point sampling, so I'll begin by implementing a helper program in Python to sample points from a Gaussian distribution and save the result to a file. Then, I'll render these points using WebGPU.</p><pre><code class="language-python code-block">import numpy as np
import codecs, json 

# Define the parameters of the Gaussian function
mu = [10, 10, 10]

cov = [[0.8084480166435242, -0.376901775598526, -0.947654664516449]
, [-0.376901775598526, 2.381552219390869, 1.5799134969711304]
, [-0.947654664516449, 1.5799134969711304, 1.899906873703003]]

# Generate the data
X = np.random.multivariate_normal(mu, cov, 10000)

json.dump(X.tolist(), codecs.open('points.json', 'w', encoding='utf-8'), 
          separators=(',', ':'), 
          sort_keys=True, 
          indent=4)</code></pre><p>The code is straightforward. The key line is <code>np.random.multivariate_normal(mu, cov, 10000)</code>, which samples 10,000 points from a multivariate normal distribution (the Gaussian). Then, we save their positions in a JSON file.</p><p><div class="img-container"><img class="img" onclick="openImage(this)" src="thumb_samples.png" original_src="samples.png" alt="Point Samples Visualized as a Point Cloud" sources='[]' /><div class="img-title">Point Samples Visualized as a Point Cloud</div></div></p><p>The covariance matrix used in the program above may appear arbitrary. I will provide an explanation of how these values were determined later in this post.</p><p>Now, let's define the single Gaussian splat we intend to render. Since the specific Gaussian splat doesn't matter for our purposes, we will simply select one at random. In this example, I've chosen a rotation represented by a quaternion of <code class="language-math math-inline">(0.601, 0.576, 0.554, 0.01)</code> and a scaling vector of <code class="language-math math-inline">(2.0, 0.3, 0.5)</code>. Quaternions and scaling vectors are used because they are the information typically stored in a Gaussian splat file.</p><p>The first step involves deriving the rotation matrix and the scaling matrix to reconstruct the covariance matrix. For this task, we will utilize the <a class="link" href="https://glmatrix.net/" target="_blank">glMatrix library</a>.</p><pre><code class="language-javascript code-block">const rot = glMatrix.quat.fromValues(0.601, 0.576, 0.554, 0.01);
const scale = glMatrix.mat3.fromScaling(glMatrix.mat3.create(), 
    glMatrix.vec3.fromValues(2.0, 0.3, 0.5));
const rotation = glMatrix.mat3.fromQuat(glMatrix.mat3.create(), rot);</code></pre><p>Then, according to equation 3, the covariance matrix can be derived as follows:</p><pre><code class="language-javascript code-block">const T = glMatrix.mat3.multiply(glMatrix.mat3.create(), rotation, scale);
const T_transpose = glMatrix.mat3.transpose(glMatrix.mat3.create(), T);
this.covariance = glMatrix.mat3.multiply(glMatrix.mat3.create(), T, T_transpose);</code></pre><p>The covariance matrix hardcoded in the Python sampling function is identical to the one calculated here.</p><p>During rendering, we update the model-view matrix based on the camera. Using this model-view matrix and the projection matrix, our goal is to accurately project the covariance matrix onto the screen plane, converting the 3D Gaussian into a 2D Gaussian.</p><p>The first step is to obtain the model-view matrix from the camera and convert it into a 3x3 matrix (the upper-left 3x3 corner). In vertex transformation with homogeneous coordinates, a 4x4 matrix is constructed for translation, with the offset values assigned to the last column of the matrix. However, when dealing with the 3x3 covariance matrix, we cannot perform translation, only rotation and scaling. Therefore, to obtain a 3x3 model-view matrix, we simply use the upper-left 3x3 corner. This is in contrast to billboarding, where the 3x3 upper-left corner is assigned the 3x3 identity matrix to remove rotation and scaling.</p><pre><code class="language-javascript code-block">const W = glMatrix.mat3.transpose(glMatrix.mat3.create(), 
  glMatrix.mat3.fromMat4(glMatrix.mat3.create(), 
  arcballModelViewMatrix));</code></pre><p>The second step involves performing perspective projection, which is akin to applying the projection matrix. In computer graphics, applying perspective projection transforms coordinates from either camera space or eye space into clip space. Prior to this transformation, the visible space is enclosed within a view frustum, which is a 3D trapezoidal volume. After the transformation, the visible space is represented as a cubic volume.</p><p><div class="img-container"><img class="img" onclick="openImage(this)" src="canonical1.png" alt="Projection Turns the View Frustum Into a Cubical Space" sources='["https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/projection-matrices-what-you-need-to-know-first.html"]' /><div class="img-title">Projection Turns the View Frustum Into a Cubical Space<a class="img-source" target="_blank" href="https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/projection-matrices-what-you-need-to-know-first.html">[SOURCE]</a></div></div></p><p>However, it's important to note that perspective transformation is not affine, which means that the original ellipsoidal shape will be warped once projected.</p><p><div class="img-container"><img class="img" onclick="openImage(this)" src="thumb_warp.png" original_src="warp.png" alt="Warping Caused by Perspective Projection" sources='["https://www.cs.umd.edu/~zwicker/publications/EWAVolumeSplatting-VIS01.pdf"]' /><div class="img-title">Warping Caused by Perspective Projection<a class="img-source" target="_blank" href="https://www.cs.umd.edu/~zwicker/publications/EWAVolumeSplatting-VIS01.pdf">[SOURCE]</a></div></div></p><p>Since non-affine transformations cannot be represented as a 3x3 matrix and applied directly to the covariance matrix, our objective is to find an approximation that can transform the Gaussian in a manner that simulates the projection.</p><p><div class="img-container"><img class="img" onclick="openImage(this)" src="thumb_warp2.png" original_src="warp2.png" alt="Illustration of Approximated Projection. Lower Left: Approximated Projection Doesn't Warp the Shape. Lower Right: Original Projection Would Warp the Shape." sources='["https://www.cs.umd.edu/~zwicker/publications/EWAVolumeSplatting-VIS01.pdf"]' /><div class="img-title">Illustration of Approximated Projection. Lower Left: Approximated Projection Doesn't Warp the Shape. Lower Right: Original Projection Would Warp the Shape.<a class="img-source" target="_blank" href="https://www.cs.umd.edu/~zwicker/publications/EWAVolumeSplatting-VIS01.pdf">[SOURCE]</a></div></div></p><p>To approximate this transformation, we first consider how a point is projected onto the screen.</p><p><div class="img-container"><img class="img" onclick="openImage(this)" src="thumb_gl_projectionmatrix03.png" original_src="gl_projectionmatrix03.png" alt="Perspective Projection of One Point to the Screen Plan" sources='["https://www.songho.ca/opengl/gl_projectionmatrix.html"]' /><div class="img-title">Perspective Projection of One Point to the Screen Plan<a class="img-source" target="_blank" href="https://www.songho.ca/opengl/gl_projectionmatrix.html">[SOURCE]</a></div></div></p><p>Given a point <code class="language-math math-inline">(x_e, y_e, z_e)</code> in camera space to be projected onto the near plane at <code class="language-math math-inline">z=n</code>, the projection can be calculated as follows:</p><p class="katex-display-counter"><code class="language-math math-block">  \begin{aligned}
  x_p &= \frac{-n x_e}{z_e}\\
  y_p &= \frac{-n y_e}{z_e}\\
  z_p &= - || (x_e, y_e, z_e)^\top ||\\
  \end{aligned}</code></p><p>This mapping from <code class="language-math math-inline">(x_e, y_e, z_e)</code> to <code class="language-math math-inline">(x_p, y_p, z_p)</code> is not affine and cannot be represented by a 3x3 matrix. According to the paper referenced <a class="link" href="https://www.cs.umd.edu/~zwicker/publications/EWAVolumeSplatting-VIS01.pdf" target="_blank">here</a>, we can approximate this transformation using the first two terms of the Taylor expansion of the mapping function: <code class="language-math math-inline">v_p + J(v-v_c)</code>, where <code class="language-math math-inline">v_p</code> is the projected centroid of the Gaussian, and <code class="language-math math-inline">J</code> is the Jacobian or the first-order derivative.</p><p>The concept of Taylor expansion, while its name might seem daunting, is actually quite straightforward. Let's illustrate it using a 1D unknown function <code class="language-math math-inline">y = f(x)</code>. Our aim is to estimate the function near a specific input point <code class="language-math math-inline">x_0</code>. When we focus on a very small window around <code class="language-math math-inline">x_0</code>, the function can be approximated by a straight line. This line can be obtained by calculating the derivative of the function <code class="language-math math-inline">f</code>. Therefore, the value of <code class="language-math math-inline">f(x)</code> where <code class="language-math math-inline">x</code> is close to <code class="language-math math-inline">x_0</code> can be approximated by <code class="language-math math-inline">\bar{y} = f(x_0) + f^\prime(x_0)(x - x_0)</code>.</p><p>In our projection scenario, <code class="language-math math-inline">f(x_0)</code> represents the projected position of the Gaussian's centroid, which we can easily calculate using the model-view matrix and the centroid position. <code class="language-math math-inline">f^\prime(x_0)</code> corresponds to the Jacobian matrix, which we will use to transform the covariance matrix.</p><p>The Jacobian matrix (transposed) can be calculated as follows:</p><p class="katex-display-counter"><code class="language-math math-block">\begin{pmatrix}
\frac{d x_p}{d x_e} & \frac{d y_p}{d x_e} & \frac{d z_p}{d x_e}\\
\frac{d x_p}{d y_e} & \frac{d y_p}{d y_e} & \frac{d z_p}{d y_e}\\
\frac{d x_p}{d z_e} & \frac{d y_p}{d z_e} & \frac{d z_p}{d z_e}\\
\end{pmatrix}</code></p><p>Based on equation 4, we can calculate the Jacobian matrix as follows:</p><p class="katex-display-counter"><code class="language-math math-block">\begin{pmatrix}
-\frac{n}{z_e} & 0 & 0\\
0 & -\frac{n}{z_e} & 0\\
\frac{x_e}{z_e^2} & \frac{y_e}{z_e^2} & 0\\
\end{pmatrix}</code></p><p>The last column should not be all zeros, but in our <a class="link" href="https://github.com/mkkellogg/GaussianSplats3D" target="_blank">reference code</a>, the last column is indeed set to zeros. I believe the reason for this is that for the projection of Gaussians, we can effectively remove the depth information by assuming <code class="language-math math-inline">z_p</code> is a constant. This is because we do not need depth testing for Gaussians; instead, we will sort them from front to back and render them in that order.</p><p>Here is how the Jacobian matrix (in column-major order) is calculated in the code, based on the perspective projection matrix:</p><pre><code class="language-javascript code-block">const focal = {
    x: projectionMatrix[0] * devicePixelRatio * renderDimension.x * 0.5,
    y: projectionMatrix[5] * devicePixelRatio * renderDimension.y * 0.5
}
const s = 1.0 / (viewCenter[2] * viewCenter[2]);
const J = glMatrix.mat3.fromValues(
    -focal.x / viewCenter[2], 0., (focal.x * viewCenter[0]) * s,
    0., -focal.y / viewCenter[2], (focal.y * viewCenter[1]) * s,
    0., 0., 0.
);</code></pre><p>The focal vector can be calculated by extracting the first and sixth elements from the projection matrix. These elements represent the horizontal and vertical arctangents of the half field of view. By multiplying them with the half width and half height of the canvas, respectively, we obtain the distance from the camera to the near plane. In theory, both focal.x and focal.y should be equal.</p><p>With both the 3x3 model-view matrix W and the Jacobian matrix J, we can now update our covariance as follows:</p><pre><code class="language-javascript code-block">const W = glMatrix.mat3.transpose(glMatrix.mat3.create(), 
  glMatrix.mat3.fromMat4(glMatrix.mat3.create(), arcballModelViewMatrix));

const T = glMatrix.mat3.multiply(glMatrix.mat3.create(), W, J);

let new_c = glMatrix.mat3.multiply(glMatrix.mat3.create(), 
  glMatrix.mat3.transpose(glMatrix.mat3.create(), T), 
  glMatrix.mat3.multiply(glMatrix.mat3.create(), this.covariance, T));</code></pre><p>With the updated covariance, we extract its 2x2 upper left corner, which represents the covariance for the projected 2D Gaussian. Next, we need to recover two basis vectors from the 2D Gaussian, which correspond to the eigenvectors of the top two eigenvalues.</p><p>This is calculated using the following <a class="link" href="https://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html" target="_blank">formula</a>:</p><pre><code class="language-javascript code-block">const cov2Dv = glMatrix.vec3.fromValues(new_c[0], new_c[1], new_c[4]);

let a = cov2Dv[0];
let b = cov2Dv[1];
let d = cov2Dv[2];

let D = a * d - b * b;
let trace = a + d;
let traceOver2 = 0.5 * trace;
let term2 = Math.sqrt(trace * trace / 4.0 - D);

let eigenValue1 = traceOver2 + term2;
let eigenValue2 = Math.max(traceOver2 - term2, 0.00); // prevent negative eigen value

const maxSplatSize = 1024.0;
let eigenVector1 = glMatrix.vec2.normalize(glMatrix.vec2.create(), 
  glMatrix.vec2.fromValues(b, eigenValue1 - a));
// since the eigen vectors are orthogonal, we derive the second one from the first
let eigenVector2 = glMatrix.vec2.fromValues(eigenVector1[1], -eigenVector1[0]);

let basisVector1 = glMatrix.vec2.scale(glMatrix.vec2.create(), 
  eigenVector1, Math.min(Math.sqrt(eigenValue1) * 4, maxSplatSize));
let basisVector2 = glMatrix.vec2.scale(glMatrix.vec2.create(), 
  eigenVector2, Math.min(Math.sqrt(eigenValue2) * 4, maxSplatSize));        </code></pre><p>In the vertex shader code, we utilize the basis vectors to construct a screen-aligned quad. The long edge of the quad should be parallel to the first basis vector, while the short edge should be parallel to the second eigenvector.</p><pre><code class="language-javascript code-block">var clipCenter:vec4<f32> = projection * modelView * pos;
var ndcCenter:vec3<f32> = clipCenter.xyz / clipCenter.w;
var ndcOffset:vec2<f32> = vec2(inPos.x * basisVector1 + inPos.y * basisVector2) 
  * basisViewport;
out.clip_position = vec4<f32>(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);</code></pre><p>In the shader code, we manually calculate the position of the centroid in Normalized Device Coordinates (NDC). Since NDC has a range of [-1, 1] for both the x and y axes, we need to scale the ndcOffset. Because the Jacobian is calculated using pixels as the unit length, we need to scale it down by <code class="language-math math-inline">(\frac{w}{2},\frac{h}{2})</code>, where <code class="language-math math-inline">w</code> and <code class="language-math math-inline">h</code> are the width and height of the canvas, respectively.</p><p><div class="img-container"><img class="img" onclick="openImage(this)" src="thumb_result.png" original_src="result.png" alt="Gaussian Rendering Result Overlapping the Ground Truth Point Cloud" sources='[]' /><div class="img-title">Gaussian Rendering Result Overlapping the Ground Truth Point Cloud</div></div></p><p>The rendering result is shown above. As we can see, the Gaussian is correctly rendered, overlapping perfectly with the ground truth point cloud.</p></article>
            <div class="older_newer_link_section">
                <div class="older_newer_link_left">
                    <p>


                        <svg xmlns="http://www.w3.org/2000/svg" height="12" width="11" fill="#dadadb"
                            viewBox="0 0 448 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.-->
                            <path
                                d="M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.2 288 416 288c17.7 0 32-14.3 32-32s-14.3-32-32-32l-306.7 0L214.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z" />
                        </svg>
                        PREV POST


                    </p>
                    <p>
                        <a class="older_newer_link" href="/quipquick">QuipQuick, My Static Blog Engine</a>
                    </p>
                </div>

                <div class="older_newer_link_right">
                    <p>
                        NEXT POST
                        <svg xmlns="http://www.w3.org/2000/svg" height="12" width="11" fill="#dadadb"
                            viewBox="0 0 448 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.-->
                            <path
                                d="M438.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L338.8 224 32 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l306.7 0L233.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l160-160z" />
                        </svg>
                    </p>
                    <p>
                        <a class="older_newer_link" href="/why_is_cloud_gaming_a_bad_business">The Perpetual Struggle of Cloud Gaming</a>
                    </p>
                </div>
            </div>
            <a href="https://github.com/shi-yan/shi-yan.github.io/discussions" target="_blank" class="comment"><svg
                    style="margin-right:10px;vertical-align: middle;" xmlns="http://www.w3.org/2000/svg" height="32"
                    width="32" fill="#dadadb"
                    viewBox="0 0 480 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.-->
                    <path
                        d="M186.1 328.7c0 20.9-10.9 55.1-36.7 55.1s-36.7-34.2-36.7-55.1 10.9-55.1 36.7-55.1 36.7 34.2 36.7 55.1zM480 278.2c0 31.9-3.2 65.7-17.5 95-37.9 76.6-142.1 74.8-216.7 74.8-75.8 0-186.2 2.7-225.6-74.8-14.6-29-20.2-63.1-20.2-95 0-41.9 13.9-81.5 41.5-113.6-5.2-15.8-7.7-32.4-7.7-48.8 0-21.5 4.9-32.3 14.6-51.8 45.3 0 74.3 9 108.8 36 29-6.9 58.8-10 88.7-10 27 0 54.2 2.9 80.4 9.2 34-26.7 63-35.2 107.8-35.2 9.8 19.5 14.6 30.3 14.6 51.8 0 16.4-2.6 32.7-7.7 48.2 27.5 32.4 39 72.3 39 114.2zm-64.3 50.5c0-43.9-26.7-82.6-73.5-82.6-18.9 0-37 3.4-56 6-14.9 2.3-29.8 3.2-45.1 3.2-15.2 0-30.1-.9-45.1-3.2-18.7-2.6-37-6-56-6-46.8 0-73.5 38.7-73.5 82.6 0 87.8 80.4 101.3 150.4 101.3h48.2c70.3 0 150.6-13.4 150.6-101.3zm-82.6-55.1c-25.8 0-36.7 34.2-36.7 55.1s10.9 55.1 36.7 55.1 36.7-34.2 36.7-55.1-10.9-55.1-36.7-55.1z" />
                </svg> Leave a Comment on Github</a>
        </div>
        <div id="right"></div>
        <div id="footer">Generated by <a class="link" href="https://github.com/shi-yan/QuipQuick"
                target="_blank">QuipQuick</a> @</div>
        <!-- The Modal -->
        <div id="img-modal" class="modal">
            <!-- The Close Button -->
            <span class="close" id="img-close">&times;</span>
            <!-- Modal Content (The Image) -->
            <img class="modal-content" id="img01">

            <!-- Modal Caption (Image Text) -->
            <div id="caption"></div>
        </div>
        <script>
            function openImage(img) {
                let modal = document.getElementById("img-modal");
                let modalImg = document.getElementById("img01");
                modal.style.display = "block";
                if (img.getAttribute("original_src")) {
                    modalImg.src = img.getAttribute("original_src");
                } else {
                    modalImg.src = img.src;
                }
                let captionText = document.getElementById("caption");

                captionText.innerText = img.alt;

                let sources = JSON.parse(img.getAttribute("sources"));

                for (let i = 0; i < sources.length; ++i) {
                    if (sources.length == 1) {
                        captionText.innerHTML += "<a href='" + sources[i] + "' target='_blank' class='img-source'>SOURCE</a>";
                    } else {
                        captionText.innerHTML += "<a href='" + sources[i] + "' target='_blank' class='img-source'>SOURCE " + (i + 1) + "</a>";
                    }
                }
            }
            // Get the <span> element that closes the modal
            var closeButton = document.getElementById("img-close");

            // When the user clicks on <span> (x), close the modal
            closeButton.onclick = function () {
                var modal = document.getElementById("img-modal");
                modal.style.display = "none";
            }
        </script>
        <script type="module">
            const macros = {};
            const mathElementsBlock = document.getElementsByClassName("math-block");
            for (let element of mathElementsBlock) {
                katex.render(element.textContent, element, {
                    throwOnError: false,
                    displayMode: true,
                    macros
                });
            }

            const mathElementsInline = document.getElementsByClassName("math-inline");
            for (let element of mathElementsInline) {
                katex.render(element.textContent, element, {
                    throwOnError: false,
                    macros
                });
            }

            hljs.highlightAll();

                    async function setBuildTime() {
                        let response = await fetch("/current_time.txt");
                        let currentTime = await response.text();
                        document.getElementById('footer').innerHTML += ' ' + currentTime;
                    }
                    setBuildTime();
        </script>
        <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag() { dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', '');
</script>
    </div>
</body>

</html>